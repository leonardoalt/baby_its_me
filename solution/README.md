# Baby it's me - SPOILER ALERT

If you don't want to know the solution stop reading right here.

## tl;dr

- The CTF can be solved by a kind of [small subgroup attack](https://en.wikipedia.org/wiki/Small_subgroup_confinement_attack).
- The [BabyJubjub](https://eips.ethereum.org/EIPS/eip-2494) curve order factors
  in 8 *
  2736030358979909402780800718157159386076813972158567259200215660948447373041.
- This means that besides the large prime subgroup there are other subgroups,
  including small ones.
- The given public key `A` is actually part of a small subgroup of size 8.
- The above allows one to manipulate the signature so that the final check passes.

## Other solution posts

If you have different solutions I'd be happy to link it here!

- https://twitter.com/popular_12345/status/1662174518696366080

## Solution

The final code that solves the challenge is quite simple, but to get there one
needs to find out some other clues on the way.

We want the check `s * G = R + k * A` to succeed, where:
- `s` is a scalar part of the signature (we control)
- `G` is the generator of the large prime subgroup (constant)
- `R` is a point part of the signature (we control)
- `k` is the hash of `A`, `R` and the message (we can influence)
- `A` is the public key we want to impersonate (constant)

The hash `k` can be influenced by our choice of `R` and the message which
itself can be influenced by changing our Ethereum address.

The first hint is the `orderCheck` function that is different in the CTF code
compared to the original ZoKrates stdlib. The new code allows the signature
parameter `R` to be a small subgroup point, except for the identity.

The next and main catch is noticing that `A` is actually a bad public key: it
is part of a small subgroup of order 8. This allows us to now manipulate the
other parameters in a way that makes the check pass.

From here there a couple different solutions that one may use:

### Variant 1

If we traverse the points in the small group of order 8 (there are 8 points
including the identity), there is a high chance that when using one of them as
`R`, `R + k * A` will be the identity point, since `k * A` is equivalent to `(k
% 8) * A`. If none of them work, one can change the hash by choosing another
Ethereum address until it succeeds. We can then set `s = 0` and make the left
hand side of the check also be the identity, validating the signature without
really checking anything.

### Variant 2

Similarly to the solution above, one may also notice that because `A` is in the
small subgroup of order 8, for any `k` (the computed hash) that is a multiple
of 8, `k * A` is the identity point. In this case, `R + k * A = R` and the
final check is `s * G = R`. Now one can simply bruteforce a scalar `s` so that
the computed `R` leads to a hash `k` that is a multiple of 8.

### Code

The code in `src/lib.rs` function `test_ctf` shows how to obtain such `R` for a
specific message generated by my Ethereum address following Variant 1. You can
change `msg_str` to be the message generated by your address and run the
function with `cargo run --release test_ctf -- --nocapture` to find an `R` that
works for you.
